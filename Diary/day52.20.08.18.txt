||shell 脚本
1:定义变量：$ name="wuff"    !!变量名和等号之间不能有空格，变量名首字母不能数字开头，不能使用关键字。变量名^[a-zA-Z_][a-zA-Z_0-9]*
2:使用变量：$ echo ${name}  //wuff,!!加{}是为了帮助解释器识别变量地边界,变量可重
新被定义。
3:只读变量:$ name="wuff" readonly name
4:删除变量：$ unset variable_name    //使用unset删除变量，变量被删除后不能再次使
用，unset不能删除只读变量。
5：变量类型：（1）局部变量，仅在当前shell实例中有效，其他shell启动的程序无法访问局部变量。（2）环境变量，所有的程序（包括shell启动的程序）都能访问环境变量。
（3）shell变量，shell变量是由shell程序设置的特殊变量，是以上两个变量的结合。

|Shell字符串
单引号：$ str='c:\desktop'  //无法使用转义符,且变量是无效的,必须$ echo 'Im '${str}''拼接。
双引号:$ str="Im in \"${name}\"" //可以使用转义符，可以直接使用变量 Im in "wuff"
获取字符串长度:$ str="12345"  \n  echo ${#str} //5
提取子字符串:$ str="012345678" \n echo ${str:2:4} //输出2345,和数组的索引类似。

|shell数组
定义数组：$ array_name=(v0 v1 v2 v3 v4) 或者 array_name[]=vn //可以不使用连续的
下标，且下标的范围没有限制。
读取数组:$ valuen=${array_name[n]}  可以使用@符号获取数组中所有元素， echo ${array_name[@]}
获取数组长度：$ length=${#array_name[@]} 
|shell注释
#.....
使用函数，将要注释的代码用{}定义成一个函数，没有地方调用函数，代码就不会执行。
多行注释：:<<EOF
EOF

|脚本传递参数：
$ $n n代表传递的第n个参数
$#：传递到脚本的参数个数。
$*:以一个单字符串显示所有向脚本传递的参数。
$$:脚本运行的当前进程ID号
$!:后台运行的最后一个进程的ID号
$@:运行的最后一个进程的ID号
$@:运行的最后一个进程的ID号
$@:与$*相同，但是使用时加引号，并在引号中返回每个参数。
如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
$-:显示Shell使用的当前选项，与set命令功能相同。
$?:显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
if [ -n "$1" ]; then
fi
!!中括号[ ]与其中间的代码应该有空格隔开。[ $var -eq 0 ] ，算数比较，是否相等。
[ -e $var ] 判断文件是否存在，[ -d $var ] 是否是目录。[ $var1 = $var2 ] 字符串比较，比较两个字符串是否相同。
|-x 参数判断 $folder 是否存在并且是否具有可执行权限if [ ! -x "$folder"]; then
-f 参数判断 $file 是否存在if [ ! -f "$file" ]; then
-n 判断一个变量是否有值if [ ! -n "$var" ]; then
判断两个变量是否相等if [ "$var1" = "$var2" ]; then

|shell基本运算符
expr 表达式计算工具，使用它能完成表达式的求值操作。注意使用的是反引号 ` 而不是单引号 '
加法：
$ var=`expr 2 + 2`  \n echo $var  //4，!!表达式和运算符要有空格。
减法：
$ var=`expr ${a} - ${b}`
乘法：
$ var=`expr ${a} \* ${b}`
除法：
$ var=`expr ${b} / ${a}`
取余：
$ var=`expr ${b} % ${a}`
赋值：
$ var=${b}
相等：
$ [ ${a} == ${b} ] 返回false
不相等：
$ [ ${a} != ${b} ] 返回true

|shell关系运算符
关系运算符只支持数字，不支持字符串，除非字符串的值是数字。
-eq:==判断数是否相等。
-ne:!=判断是否不相等。
-gt:>检测左边的数是否大于右边。
-lt：<检测左边的数是否小于右边。
-ge：>=
-le:<=

|shell布尔运算符
!:^非  [ ! false ]
-o:或运算  [ ${a} -gt 20 -o ${b} -gt 100 ]   a>20|b>100
-a:与运算  [ ${b} -ge 20 -a ${b} -le 100 ]   b>-20&b<=100

|shell逻辑运算符
&&:；逻辑的AND [[ $a -lt 100 && $b -gt 100 ]]
||： 逻辑的OR [[ $a -lt 100 || $b -gt 100 ]]

shell字符运算符
=:检测两个字符串是否相等 [ $a = $b ]
!=:
-z:检测字符串长度是否为0，为0返回 true。 [ -z $a ]
-n:检测字符串长度是否不为 0，不为 0 返回 true。 [ -n "$a" ]
$:检测字符串是否为空，不为空返回 true。 [ $a ]

|shell文件测试运算符
文件测试运算符用于检测 Unix 文件的各种属性。
-b:检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ]
-c:检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ]
-d:检测文件是否是目录，如果是，则返回 true。 [ -d $file ]
-f:检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。
-g:检测文件是否设置了 SGID 位，如果是，则返回 true。
-k:检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。
-p:检测文件是否是有名管道，如果是，则返回 true。
-u:检测文件是否设置了 SUID 位，如果是，则返回 true。
-r:检测文件是否可读，如果是，则返回 true。
-w:检测文件是否可写，如果是，则返回 true。
-x:检测文件是否可执行，如果是，则返回 true。
-s:检测文件是否为空（文件大小是否大于0），不为空返回 true。
-e:检测文件（包括目录）是否存在，如果是，则返回 true。
-S:判断某文件是否 socket。
-L:检测文件是否存在并且是一个符号链接。

|shell流程控制
if[  ]; then
else
fi

if[ ]; then
elif []; then
else
fi

|shell
&& 运算符:
格式
command1  && command2
&&左边的命令（命令1）返回真(即返回0，成功被执行）后，&&右边的命令（命令2）才能够被执行；换句话说，“如果这个命令执行成功&&那么执行这个命令”。
语法格式如下：
command1 && command2 && command3 ...
1.命令之间使用 && 连接，实现逻辑与的功能。
2.只有在 && 左边的命令返回真（命令返回值 $? == 0），&& 右边的命令才会被执行。
|| 运算符:
格式
command1 || command2
||则与&&相反。如果||左边的命令（command1）未执行成功，那么就执行||右边的命令（command2）；或者换句话说，“如果这个命令执行失败了||那么就执行这个命令。
echo $BASH |grep -q 'bash' || { exec bash "$0" "$@" || exit 1; }    系统调用exec是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。
() 运算符:
如果希望把几个命令合在一起执行，shell提供了两种方法。既可以在当前shell也可以在子shell中执行一组命令。
格式:
(command1;command2;command3....)               多个命令之间用;分隔
1.一条命令需要独占一个物理行，如果需要将多条命令放在同一行，命令之间使用命令分隔符（;）分隔。执行的效果等同于多个独立的命令单独执行的效果。
2.() 表示在当前 shell 中将多个命令作为一个整体执行。需要注意的是，使用 () 括起来的命令在执行前面都不会切换当前工作目录，也就是说命令组合都是在当前工作目录下被执行的，尽管命令中有切换目录的命令。
{} 运算符:
如果使用{}来代替()，那么相应的命令将在子shell而不是当前shell中作为一个整体被执行，只有在{}中所有命令的输出作为一个整体被重定向时，其中的命令才被放到子shell中执行，否则在当前shell执行。
它的一般形式为：
{ command1;command2;command3… }      注意：在使用{}时，{}与命令之间必须使用一个空格




