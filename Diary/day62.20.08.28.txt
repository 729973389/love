||Go gc:
Mutator->Allocator->Heap<-Collector
用户程序(Mutator)会通过内存分配器(Allocator)在堆上申请内存，而垃圾收集器(
Collector)负责回收堆上的内存空间，内存分配器和垃圾收集器共同管理着程序中的
堆内存空间。
|标记清除：
标记清除（Mark-Sweep）算法是最常见的垃圾收集算法，标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：
标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；
清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表；
标记阶段结束后会进入清除阶段，在该阶段中收集器会依次遍历堆中的所有对象，释放其中没有被标记的 B、E 和 F 三个对象并将新的空闲内存空间以链表的结构串联起来，方便内存分配器的使用。
这里介绍的是最传统的标记清除算法，垃圾收集器从垃圾收集的根对象出发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活；标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程需要标记对象的存活状态，用户程序在垃圾收集的过程中也不能执行，我们需要用到更复杂的机制来解决 STW 的问题。

|三色抽象：
为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类4：
白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；
黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；
在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。

|插入写屏障：
Dijkstra 在 1978 年提出了插入写屏障，通过如下所示的写屏障，用户程序和垃圾收集器可以在交替工作的情况下保证程序执行的正确性：
$$ writePointer(slot,ptr):
shade(ptr)//染色
*slot=ptr//指向下一个对象
上述插入写屏障的伪代码非常好理解，每当我们执行类似 *slot = ptr 的表达式时，我们会执行上述写屏障通过 shade 函数尝试改变指针的颜色。如果 ptr 指针是白色的，那么该函数会将该对象设置成灰色，其他情况则保持不变。

|三色标记垃圾收集器的工作原理：
1.
从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
2.
将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
3.
重复上述两个步骤直到对象图中不存在灰色对象；
4.
当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾
5.因为用户程序可能在标记执行的过程中修改对象的指针，想要并发或者增量地标记对象还是需要使用屏障技术。
屏障技术：
内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循
特定的约束，目前的多数的现代处理器都会乱序执行指令以最大化性能，但是该技术
能够保证代码对内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后
执行的操作。
想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的任意一种：
1.强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象，所
以引入插入写屏障，当程序修改A指针的指向C对象时，触发写屏障将C对象标记成灰色
垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；
2.弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对
象的可达路径。重新扫描栈对象时需要暂停程序。

增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；
并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；

因为并发垃圾收集器会与程序一起运行，所以它无法准确的控制堆内存的大小，并发收集器需要在达到目标前触发垃圾收集，这样才能够保证内存大小的可控，并发收集器需要尽可能保证垃圾收集结束时的堆内存与用户配置的 GOGC 一致。

| Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障，该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色：
$$writePointer(slot, ptr):
shade(*slot)
if current stack is grey:
   shade(ptr)
*slot = ptr
$$

