看了复合数据类型，复合数据类型由基础数据类型以各种组合而构成，分别是：数组，slice，map，和结构体struct，他们都具有索引和索引对应的值。 数组和结构体由内存中的一组变量构成，数组的元素具有相同的类型，而结构体的元素类型可以不同，数组和struct的长度都是固定的。而slice和map都是动态数据结构，在添加元素时长度可以动态增长。	数组：长度固定，存储的相同类型元素的序列。在数组字面量中，如果...出现在数组长度的位置，那么数组的长度由初始化数组的元素个数决定。如$ q := [...]int{1,2,3};len(q)==3 ok;数组的长度数是数组类型的一部分，它的长度必须是常量表达式。 ||当调用一个函数的时候，每个传入的参数都会创建一个副本，然后赋值给对应的函数变量，所以函数接受的是一个副本，而不是原始的参数。，所以要显式地传递一个数组地指针给函数，这样函数内部对数组的任何修改都会反映到数组上面。	slice：slice表示一个拥有相同类型元素的可变长度的序列，即[ ]T，元素的类型为T。slice是一种轻量级的数据结构，可以用来访问底层数组的部分或全部的元素，。slice拥有三个属性：指针ptr（指向slice访问的第一个元素）、长度len（slice中元素的个数，不能超过cap）、和容量cap（slice的起始元素到底层数组的最后一个元素。slice的操作符s[i:j]创建一个新的slice引用从i到j-1索引的所有元素。这个s既可以是数组也可以是指向数组的指针，也可以是slice。因为slice包含了指向元素的指针，所以将slice传递给函数的时候，可以在函数内部修改底层数组的元素。slice的元素不是直接的，如果底层数组元素改变，同一个slice在不同的时间会拥有不同的元素，由于散列表（如Go的map类型）仅对元素的键做浅拷贝，要求散列表里面的键在散列表的整个生命周期内必须保持不变。因为slice需要深度比较，所以不能用slice作为map的键。slice唯一允许的比较操作是和nil做比较。想要检查一个slice是否为空，使用$len(s)==0 ok$判断，因为$s != nil $的情况下，slice也有可能是空。内置函数make可以创建一个具有指定元素类型、长度、容量的slice，其中容量参数省略是，长度和容量相等，其实make创建了一个无名数组并返回了它的一个slice，这个数组仅可以通过这个slice访问。内置函数append用来将元素追加到slice的后面，内置函数copy用来为相同类型元素的slice复制元素，copy函数的第一个参数是目标slice，第二个参数是源slice，copy函数有返回值，返回实际上复制元素的个数，这个值是两个slice长度的较小值，所以不存在由于元素复制而导致的索引越界问题。处于效率考虑，每次底层数组的扩容都通过扩展一倍的容量来减少内存分配的次数，每次slice容量的改变都意味着一次底层数组重新分配和元素复制。对于任何函数，只要有可能改变slice的长度或者容量、抑或是使得slice指向不同的底层数组，都需要更新slice变量，虽然底层数组的元素是间接引用的，但是slice的指针，长度，和容量不是，所以要更新一个slice的指针，长度或容量必须使用显式赋值，从这个角度看，slice并不是纯引用类型，而是更像下面这种聚合类型：$ type IntSlice struct {ptr *int ,len,cap int,}$。slice就地修改，slice拥有相同的底层数组:$func nonempty2(strings [ ]string)[ ]string {out := strings[:0]//引用原始slice的新的长度为0的slice\n for _, s := range strings \n {if s != nil {out=append(out,s)}}return out},重用底层数组的结果是每一个输入的slice最多只有一个输出的结果slice。	map:散列表是一个拥有键值对元素的无序集合。在这个集合中，键的值是唯一的，键对应的值可以通过键来获取，更新，或移除。在Go语言中，map是散列表的引用，map的类型是$map[k]v$,其中k和v是字典的键和值对应的数据类型。类型K必须是可以通过操作符$==$来进行比较的数据类型，所以map可以检测一个键是否已存在。虽然浮点型是可以比较的，但是比较浮点型的相等性不是一个好主意，值类型V没有任何限制。内置函数make可以用来创建一个map$ages := make([string]int) $.可以使用内置函数delete来从字典中删除一个元素:$delete(map, key)$,即使key不在map中，上面的操作也是安全的。map元素不是一个变量，不可以获取它的地址。我们无法获取map元素的地址的一个原因是map的增长可能会导致已有元素被重新散列到新的存储位置，这样可能使得获取的地址无效。map中元素的迭代顺序是不固定的，不同的实现方法会使用不同的散列算法，得到不同的元素顺序，这样可以使得程序在不同的散列算法下变得健壮。设置元素之前。必须初始化map。可以通过$k,ok := map[K]$来判断该元素是否存在。