||go trace 
$$ import (
"os"
"runtime/trace"
)

func main() {
	trace.Start(os.Stderr)
	defer trace.Stop()
	
	.
	.
	.
}

$go run main.go 2>trace.out
$go tool trace trace.out

||http2
piprlining:
不等待响应，直接发送下一个请求，但是客户端还是要按照发送请求的顺序来接收响应。
|HOLB(Head of line blocking)线头阻塞

|http1.x:
start line->header->body
|http2.0:
length->type->flags->stream id->payload
HTTP2连接上传输的每个帧都关联一个stream.

HTTP2还有一些比较重要的改动：
使用HPACK对HTTP/2头部压缩
服务器推送
流量控制
针对传输中的流进行控制(TCP默认的粒度是针对连接)
流优先级（Stream Priority）它被用来告诉对端哪个流更重要。
对称加密：
加密和解密都是用同一个密钥
非对称加密：
加密用公开的密钥，解密用私钥
(私钥只有自己知道，公开的密钥大家都知道)
数字签名：
验证传输的内容是对方发送的数据
发送的数据没有被篡改过
数字证书（Certificate Authority）简称CA
认证机构证明是真实的服务器发送的数据。

||go func 函数
定义：
函数包含连续的执行语句，在代码中通过调用函数来执行他们。函数将负责的工作切分成多
个更小的模块，使得多人协作变得更加容易。此外，函数对使用者隐藏实现细节。这章了解
到Go语言的递归、匿名函数、错误处理等方面的函数特性。
|5.1 函数声明：
每一个函数声明包含：一个名字Name，一个形参列表(parameter-list),一个可选的返回列表(resu
lt-list)以及函数体{}.
func Name(parameter-list)(result-list){
	body
}
  1.形参列表（parameter-list）指定勒一组变量的参数名和参数类型，这些局部变量都由调用者提供的实参传
递而来。
  1.返回列表（result-list）则指定了函数返回值的类型。当函数返回一个未命名的返回值或者没有返回值的时
返回列表的圆括号可省略。如果函数没有任何返回值，则设计这个函数的目的是调用函数之后所带来的附加效果
。2.当函数返回值也可以像形参一样命名。这个时候每一个命名的返回值会声明为一个局部变量，并根据变量的

  函数的类型称作函数签名，当两个函数拥有相同的形参列表和返回列表时，认为两个函数的类型或者函数签名
时相同的.如 func(int,int)int 。
  每一次调用函数都需要提供实参来对应函数的每一个形参，包括参数的调用顺序也必须一致。
  形参变量都是函数的局部变量，初始值由调用者提供的实参传递，函数形参以及命名返回值同属于函数最外层
作用域的局部变量。
  实参是按值传递的，所以函数接收到的是每个实参的副本，除非收到的是指针、slice、map、函数、或channel
否则修改函数的形参肯定不会影响到调用者提供的实参。
  有些函数的声明没有函数体，那么说明这个函数使用除了Go以外的语言实现，这样的声明定义了该函数的签名
：package math
func Sin(x float64) float64 //使用汇编语言实现。

|5.2递归
  函数可以递归调用，意味着函数可以直接或者间接地调用自己，递归可以处理许多带有递归特性的数据结构。
非标准包:golang.org/x/net/html提供了解析HTML的功能。golang.org/x/..下的仓库，比如（网络，国际化语言
处理、移动平台、图片处理、加密功能及开发者工具）都由Go团队负责设计与维护，这些包不属于标准库，原因
是它们还在开发中或者很少被Go程序员使用。
  golang.org/x/net/html API：html.Parsed读入一段字节序列，解析它们，然后返回HTML文档树的根节点html.
Node。HTML有很多节点，比如文本、注释等。但我们只关心表单的元素节点<name kry='value'>。

|多返回值
  fmt.Errorf()error 格式化处理过的附加的上下文并返回error类型。
  我们必须保证resp.Body正确关闭使得网络资源正常释放，Go语言的垃圾回收机制将回收未使用的内存，但不能
指望它会释放未使用的操作系统资源，比如打开的文件以及网络连接，必须显式地关闭它们。
  如果调用者要使用这些返回值，必须显式地将返回值赋值给变量。也可以使用空标识符“_”来忽略值。
  返回一个结果可以是调用另一个有相同的返回函数，如：
 $$func findLinksLog(url string) ([]string,error){
	log.Printf("findLinks %s ",url)
	return findLinks(url)
}$$
  一个多值调用可以作为单独的实参传递给拥有多个形参的函数，这个特性有时候可以方便调试，下面两条语句
的效果是一致的：
$$ log.Println(findLinks(url))
$$  links,err:=findLinks(url)
    fmt.Println(links,err) $$
  良好的名称可以使得返回值更加有意义。尤其是一个函数有多个返回值的时候，名字的选择更加重要。
  一个函数如果有命名的返回值。可以省略return语句的操作数，这称为裸返回：
$$  func main(){
        fmt.Printf("%q\n",Test1())
}

func Test1()(s string){
        return
}   $$  //out:""
裸返回可以消除重复代码，但是不能使代码更加易于理解。鉴于此，应该保守使用裸返回。

|5.4错误
  即使在高质量的代码中，也不一定保证能成功返回，因为有些因素并不受程序设计者的掌控，比如任何I/O的函
数都一定会面对可能的错误，很多可靠的操作都可能毫无征兆地发生错误。因此错误处理是包地API设计重要部分
，发生错误只是许多预料行为中的一种而已。这就是Go语言处理错误的方法。
  习惯性上将错误值作为最后一个结果返回。如果错误只有一种情况，结果通常设为bool值。更多时候，尤其是
对I/O操作，错误的原因可能多种多样，调用者需要详细的错误信息，所以错误的结果类型往往是error.
  error是内置的接口类型，一个错误可能是空值或者非空值，空值意味着成功而非空值则意味着失败，且非空的
错误类型有一个错误消息字符串，可以通过调用error方法或者fmt,Println(err)、fmt.Printf("%v",err)
  一般当一个函数返回一个非空错误时，它与其他的结果都是未定义的且应该忽略(如resp,err:=http.Do(req))
。然而有一些函数在调用出错的情况下会返回部分有用的结果，比如读取文件时发生错误，正确的行为是在处理
错误前先处理这些不完整的返回结果，因此在文档中清晰地说明返回值的意义是非常重要的。
  与其他语言不同，Go语言使用普通的值而非异常来报告错误。这样做的原因是异常会陷入带有错误消息的控制
流去处理它，通常会导致预期外的结果。错误会以难以理解的栈跟踪信息报告给最终用户，这些信息大都是关于
程序结构方面的而不是简单明了的错误消息。所以Go使用通常的控制流机制(比如if和return语句来应对错误）。
所以需要在错误处理逻辑方面要求更加小心谨慎，但这恰恰是设计的要点。

5.4.1错误处理策略：
  当一个函数调用返回一个错误的时，调用者应当负责检查错误并采取合适的处理应对。
1.将错误传递下去，使得在子例程中发生的错误变为主例程的错误。fmt.Errorf使用fmt.Sprintf函数格式化一条
错误消息并返回一个新的错误值。我们不断地为原始的错误消息添加额外的上下文来简历一个可读的错误描述。
当错误最终被程序的main函数处理时，它应当能够提供一个从最根本问题到总体故障的清晰因果链。如NASA事故
调查：
$ genesis: crashed: no patachute: G-switch failed: bad relay orientation
因为错误消息频繁地串联起来，所以消息字符串首字母不应该大写而且应该避免换行，否则错误结果可能会很长
，但能够使用grep这样的工具来找到我们想要的信息。
设计一个错误消息时应当慎重，确保每一条消息的描述都是有意义的，包含充足的信息，并且保持一致性。f(x)
调用只负责报告函数的行为f和参数值x,因为它们和错误的上下文相关。调用者只需要负责添加进一步的信息。

2.对于不固定或者不可预测的错误，在短暂的间隔后对操作进行重试时合乎情理的，超过一定的重试次数和限定
时间后再报错退出。

3.如果依旧不能顺利进行下去，调用者能够输出错误然后优雅地停止程序，但一般这样的处理应该留给主程序部
分。通常库函数应当将错误传递给调用者，除非这个错误表示内部一致性错误，这意味着库内内部存在bug。默认
的格式有助于长期运行的服务器，而对于交互式的命令行工具则意义不大。一种更吸引人的输出方式是自己定义
命令的名称作为log包的前缀。：
$log.SetPrefix("wait: ")
log.SetFlags(0)

4.在一些错误下，只记录下错误信息然后程序继续运行。：
$if err:=ping();err!=nil{
log.Printf("ping failed: %v; network disabled",err)
}$
并且输出到标准错误流：
$if err:=Ping();err!=nil{
fmt.Eprintf(os.Stderr,"ping failed: %v; network disabled\n",err)
}$
（所有log函数都自动为缺少换行符日志补充一个换行符。）

5.在某些罕见的情况下可以直接安全地忽略掉整个日志。
$ var out bytes.buffer
for{
	lines,err:=out.ReadString('\n')
	if err != nil {
		break
	}
} $$
要习惯考虑到每一个函数调用可能发生地出错情况，当你有意地忽略一个错误的时候，清楚地注释一下意图。
  Go语言的错误处理有特定的规律。进行错误检查之后，检测到失败的情况会在成功之前。如果检测到的失败导
致函数返回，成功的逻辑一般不会放在else块中而是在外层作用域中。函数会有一种通常的形式，就是在开头有一连串的错误检查用来返回错误，之后跟着实际的函数体一直到最后。

5.4.2文件结束标识
通常当尝试地读取固定大小的块直到文件耗尽，调用者必须把读取到文件尾的情况区别于遇到其他错误的操作。
为此，io包保证任何由文件结束引起的错误，始终都会得到一个与众不同的错误--io.EOF:
$ package io
import "errors"
var EOF=error.New("EOF")
$

|5.5函数变量
  函数在Go语言中是头等重要的值：就像其他值，函数变量也有类型（即函数签名），而且它们也可以赋值给变
量或者传递或者从其他函数中返回。函数变量可以像其他函数一样调用。比如：
$$func square(n int)int {return n*n}
f:=square
fmt.Println(square(3))//"9"
fmt.Printf("%T",f)//"func(int)int"
$$
函数类型的零值是nil（空值），调用一个空的函数变量将导致宕机。如：
$$var f func(int)int
f()//panic:调用空函数
函数变量可以和nil作比较。但它们本身不可比较，所以不可以互相进行比较或者作为键值出现在map中。
函数变量使得函数不仅将数据进行参数化，还将函数的行为当作参数传递。





