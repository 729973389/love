今天写mqtt协议的鉴权过程，其中将UTC时间转换为aaaabbccdd形式，我的方法是先	1用time.LoadLocation("UTC")将时区的位置改成UTC，并用local,err来接收返回的值.	2.使用time.now().In(local)来获得我string类型的UTCTime,并用utc来接收。	3使用strings.Replace(string,old string,new string,-1)来将utc里面的空格和-去掉.	4。使用 for range 遍历我们整型过的utc,通过 yyyymmddhh += string(value)，来获取我们前10个字符，值得注意的是，这里面的value是rune类型。	5.使用hmac.New(sha256.New,[]byte(yyyymmddhh))来使用sha256算法，以我们的时间戳为密钥进行hmac加密，并用 h 接收返回的hash值，通过h.Write([]byte(secrect))将hash值与secrect一起拼接，通过_,err 来接收返回的参数判断是否出错，最后通过hex.EncodingToString(h.sum(nil))将hash值转为string类型，值得注意的是Hash.Sum(b []byte) []byte,将hash值转换为byte切片。			此外，又重新梳理了一下mqtt的连接，首先需要一个mqtt.NewClientOptions来得到一个*ClientOptions结构体，然后就可以SetClientId().  setUserName().  SetPassword().  SetKeepAlive(int * time.second). 值得注意的是SetOnConnectHandler(onconnect OnConnectHandler)，而这个OnConnectHandler是这样的：type OnConnectHandler func(client，error) ,所以只要一个匿名函数，里面传入client和error即可。 			这里最重要的还有一个tlsconfig，流程如下：1.首先使用x509.NewCerPool()来创建CertPloo并用certpoll来接收他的地址。	2.通过(*CertPoll) func AppendCertsFromPem([]byte( " 证书内容" ))，将我们的证书添加到CertPool中，用接收返回的ok来判断是否成功。	3.使用tls.Config{RootCAs: （*）certpool}将Config结构中的RootCA指针指向更新好的Certpool,并返回结构的地址以便使用SetTLSConfig(*tls.COnfig).