今天上午准备将生成的exe文件在边缘设备运行，使其能访问iot平台，由于需要更改host文件，所以要 vim /etc/resolv/hosts i切换成输入模式，wq保存并退出，使用chmod 文件名 777 修改其权限,然后./文件名运行，访问成功。下午要运行访问iot边缘，所以重写了下mqtt代码，但是大同小异。鉴权需要clientId,setUsetName,setPassword,setTLSConfig,clientId:=deciceId_0_1_yyyymmddhh,password:=Hex.EncodeToString(HMAC.New(Hash.New,[]byte(yyyymmddhh)).write([]byte(secret)).sum(nil)),tlsconfig:=tls.Config{RootCAs:x509.NewCertPool().AppendFromPEM(byte[]ca),InsecureSkipverify:true }。	晚上看了go程序设计语言第三章，主要内容如下	1.Go的数据类型分四大类：1基础类型数字，字符串，布尔（basic type）,   2聚合类型数组，结构体（aggreate type）,   3引用pointer，slice，map，func，channel（reference type）,4接口类型(interface type)	1.整数：%仅能用于整数，/取决于操作数类型，算数和逻辑的操作类型必须相同，缩减大小的整型转换可能会改变值，如var f floa64 =3.99 int(f)输出为3，向下取整。	2.浮点数：floa32有效数字大约是6位，float64有效数字大约是15位，math.IsNaN判断参数是否为非数值，一个函数的返回值是浮点型且它有可能出错，则最好单独报错。	3复数：	4布尔值：	5.字符串：字符串是不可变的字节序列，len()返回字符串的字节数，s[i:j]则>=i,<j<=len(s),用加号可以连接两个字符串，字符串不可变意味着开销低廉，两个字符串能安全地公用同一段底层内存，rune 的底层数据结构是int32.UTF8编码最多追溯三个字节，它的最高位声明它是几位的ascll码。  （1）strings包提供了搜索，替换，比较，修整，切分，连接字符串。（2）byte包类似，用于操作slice，由于字符串不可变，所以会导致多次内存分配和复制。（3）strconv包具备的函数用于布尔值，整数，浮点数与字符串之间的相互转换。（4）Unicode包的函数提用于判别文字符号值的特性。(5)bytes包提供了更高效处理slice的Buffer类型，此类型变量后面可以添加任意添加文字字符。strconv.Itoa() /*<integer to ASCLL>*/还有atoi	6.常量：常量恒定，会复用前面的声明，iota常量生成器，从0开始逐步加1，无类型的常量其字面量由语法决定